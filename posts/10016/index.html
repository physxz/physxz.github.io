

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.jpg">
  <link rel="icon" href="/img/avatar.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Shixin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Grokking Algorithms, by Aditya Bhargava">
<meta property="og:type" content="article">
<meta property="og:title" content="算法基础">
<meta property="og:url" content="https://physxz.github.io/posts/10016/index.html">
<meta property="og:site_name" content="Shixin&#39;s blog">
<meta property="og:description" content="Grokking Algorithms, by Aditya Bhargava">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://physxz.github.io/img/20220101-algorithm.png">
<meta property="article:published_time" content="2022-01-01T02:25:00.000Z">
<meta property="article:modified_time" content="2022-07-08T09:08:13.935Z">
<meta property="article:author" content="Shixin">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://physxz.github.io/img/20220101-algorithm.png">
  
  
  <title>算法基础 - Shixin&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/email.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"physxz.github.io","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"❤","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"2c6dc07d9ee870c7c5cde51c6acbce2d","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Shixin&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bloom.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="算法基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-01 10:25" pubdate>
        2022年1月1日上午10点25分
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      165 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法基础</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年7月8日下午5点08分
                
              </p>
            
            <div class="markdown-body">
              <p>Grokking Algorithms, by Aditya Bhargava<span id="more"></span>。本书代码<a target="_blank" rel="noopener" href="https://github.com/egonSchiele/grokking_algorithms">地址</a>。</p>
<h1 id="算法简介">1 算法简介</h1>
<h2 id="二分法">二分法</h2>
<p>对于包含n个元素的列表，简单查找法最多需要n步（线性时间），而二分法查找最多需要<span class="math inline">\(log_2\ n\)</span>步（简写为<span class="math inline">\(log\ n\)</span>）（对数时间 / l<span class="math inline">\(og\)</span>时间）。</p>
<p>仅当列表是有序的时候，二分查找才管用。</p>
<h2 id="大o表示法big-o-notation运行时间">大O表示法（Big <em>O</em> notation）——运行时间</h2>
<p>简单查找法编写起来容易，出bug可能性小，但运行时间慢。二分法相反。大O表示法给出的运行时间是最大运行时间。</p>
<p>常见大O运行时间</p>
<ul>
<li><span class="math inline">\(O(log\ n)\)</span>，对数时间，包括二分查找</li>
<li><span class="math inline">\(O(n)\)</span>，线性时间，包括简单查找</li>
<li><span class="math inline">\(O(n\ log\ n)\)</span>，包括快速排序——一种速度较快的排序算法，以及合并排序</li>
<li><span class="math inline">\(O(n^2)\)</span>，包括选择排序——一种速度较慢的排序算法</li>
<li><span class="math inline">\(O(n!)\)</span>，包括后续的旅行商问题的解决方案——一种非常慢的算法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分法 #################################</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">numList,item</span>):</span><br>    low = <span class="hljs-number">0</span><br>    high = <span class="hljs-built_in">len</span>(numList) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> low &lt;= high:<br>        mid = (low + high) // <span class="hljs-number">2</span><br>        guess = numList[mid]<br>        <span class="hljs-keyword">if</span> guess &lt; item:<br>            low = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> guess &gt; item:<br>            high = mid -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> guess<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>numList = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>))<br>guess = binary_search(numList,<span class="hljs-number">34</span>)<br><span class="hljs-built_in">print</span>(guess)<br><br><span class="hljs-comment"># exercise #################################</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string"># 1.1,1.2</span><br><span class="hljs-string">import math</span><br><span class="hljs-string"></span><br><span class="hljs-string">print(math.log(128,2)) # 7步</span><br><span class="hljs-string">print(math.log(128*2,2)) # 8步</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">1.3 O(log n)</span><br><span class="hljs-string">1.4 O(n)</span><br><span class="hljs-string">1.5 O(n)</span><br><span class="hljs-string">1.6 O(n)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># 阶乘 ##################</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">import math</span><br><span class="hljs-string">print(math.factorial(5)) # 120</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h1 id="选择排序">2 选择排序</h1>
<h2 id="数组和链表">数组和链表</h2>
<ul>
<li><p>数组元素在内存中都是相连的（紧靠在一起）。</p>
<p>分配的内存空间如果小于元素个数，就需要转移位置。为了避免这一点，可以申请预留位置，但这样造成了内存的浪费。元素个数大于申请预留位置的个数后还要转移位置。但数组可以直接访问任何元素。在同一数组中，所有元素的类型都必须相同（都为int、double等）。</p>
<p><strong>数组的优势在读取元素方面，数组支持随机访问。</strong></p></li>
<li><p>链表中的元素可以存储在内存中的任何地方。</p>
<p>链表中的每个元素都存储了下一个元素的地址，从而使一系列随机的内存串在一起。但是正因为这个特点，链表不能跳跃访问中间的元素，而必须从第一个元素开始向后一级一级访问。</p>
<p><strong>链表的优势在插入和删除元素方面，链表只支持顺序访问。</strong></p></li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读取</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr class="even">
<td>插入</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr class="odd">
<td>删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h2 id="选择排序-1">选择排序</h2>
<p>遍历列表（n个元素），依次找出最大值、次大值......最小值，存储到新列表中。每个值遍历一遍，要遍历n遍，每一遍里面要查找n、n-1......1次。平均每次查找0.5xn次，因此运行时间为O(nx0.5xn)，但大O表示法省略0.5这样的常数，因此简单的写作O(n<sup>2</sup>)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找到最小值的索引 ########################</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findSmallest</span>(<span class="hljs-params">arr</span>):</span><br>    smallest = arr[<span class="hljs-number">0</span>]<br>    smallest_index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(arr)): <span class="hljs-comment"># 不包含0位置处的值（len()也不包含最后一个值，数值是0到len()-1）</span><br>        <span class="hljs-keyword">if</span> arr[i] &lt; smallest:<br>            smallest = arr[i]<br>            smallest_index = i<br>    <span class="hljs-keyword">return</span> smallest_index<br><br><span class="hljs-comment"># 选择排序算法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>):</span><br>    newArr = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br>        smallest = findSmallest(arr)<br>        newArr.append(arr.pop(smallest))<br>        <span class="hljs-comment"># 最开始总数是n，第一次遍历，将arr中选出来的最小值删除，总数为n-1，第二次遍历再删掉，总数为n-2，依次递归</span><br>        <span class="hljs-comment"># [pop()函数删除列表中的值并！！返回被删除的值！！]</span><br>        <span class="hljs-comment"># arr.pop()将arr中的值删除并返回这个值，这里也就是最小值，然后这个值被append函数添加到newArr中</span><br>        <span class="hljs-comment"># 也就是说第一次遍历添加的是n个数中的最小值，第二次添加的是n-1个数中的最小值</span><br>    <span class="hljs-keyword">return</span> newArr<br>    <br>arr = [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>newArr = selectionSort(arr)<br><span class="hljs-built_in">print</span>(newArr)<br><br><span class="hljs-comment"># excerice #############################</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">问题:如果从第一个元素处插入元素，则后面的元素都要后移一位，这样运行时间就是O(n)</span><br><span class="hljs-string">2.1 链表</span><br><span class="hljs-string">2.2 链表</span><br><span class="hljs-string">2.3 有序数组</span><br><span class="hljs-string">2.4 慢，如果用二分法查找用户名，数组必须是有序的，加入一个A开头的名字注册用户，这个用户名将插入到数组末尾。因此必须对数组排序</span><br><span class="hljs-string">2.5 查找时速度比数组慢，但比链表快；而插入时速度比数组快，但预链表相当。</span><br><span class="hljs-string">    Facobook使用的是基于众多不同的数据结构（散列表，B树等）的数据库。</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h1 id="递归">3 递归</h1>
<p>从套娃盒子中拿出钥匙的两种方法</p>
<ul>
<li><p>while循环（自己创建盒子堆）</p>
<ul>
<li>创建一个要查找的盒子堆</li>
<li>从盒子堆取出一个盒子，在里面找。</li>
<li>如果找到的是盒子，就将其加入盒子堆中，以便以后再查找。</li>
<li>如果找到钥匙，则大功告成！</li>
<li>如果没找到钥匙，回到第二步。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">look_for_key</span>(<span class="hljs-params">main_box</span>):</span><br>    pile = main_box.make_a_pile_to_look_through()<br>    <span class="hljs-keyword">while</span> pile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty:<br>        box = pile.grab_a_box()<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> box:<br>            <span class="hljs-keyword">if</span> item.is_a_box():<br>            	pile.append(item)<br>            <span class="hljs-keyword">elif</span> item.is_a_key():<br>            	<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;found the key!&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><p>递归——函数调用自己（盒子堆存储在栈中）</p>
<ul>
<li>检查盒子中的每样东西</li>
<li>如果是盒子，就回到第一步</li>
<li>如果是钥匙，就大功告成！</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">look_for_key</span>(<span class="hljs-params">box</span>):</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> box:<br>        <span class="hljs-keyword">if</span> item.is_a_box():<br>        	look_for_key(item) <span class="hljs-comment"># 递归</span><br>        <span class="hljs-keyword">elif</span> item.is_a_key():<br>        	<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;found the key!&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。</strong>如何选择要看什么对你来说更重要。<a target="_blank" rel="noopener" href="http://stackoverflow.com/a/72694/139117">参见</a>。</p>
<h2 id="基线条件和递归条件">基线条件和递归条件</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countdown</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">if</span> i &lt;=<span class="hljs-number">0</span>: <span class="hljs-comment"># 基线条件，何时停止，函数不再调用自己</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 递归条件，函数调用自己</span><br>        countdown(i-<span class="hljs-number">1</span>)<br><br>countdown(<span class="hljs-number">3</span>) <span class="hljs-comment"># 调用函数</span><br></code></pre></td></tr></table></figure>
<h2 id="栈调用栈call-stack">栈、调用栈（call stack）</h2>
<p>栈只有两种操作：压入（插入）和弹出（删除并读取）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello,&#x27;</span>,name+<span class="hljs-string">&#x27;!&#x27;</span>)<br>    greet2(name)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;greeting ready to say bye...&#x27;</span>)<br>    bye()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet2</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;how are you,&#x27;</span>,name+<span class="hljs-string">&#x27;?&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bye</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ok bye!&#x27;</span>)<br><br>greet(<span class="hljs-string">&#x27;zhao&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>递归调用栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fact</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">if</span> x &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> x * fact(x-<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(fact(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure>
<p>回到最开始的套娃盒子问题，while循环需要自己创建盒子堆，而递归不需要，因为盒子堆存储在栈中。这样使得使用栈很方便，但是这样可能会占用大量内存，如果栈很高，计算机就存储了大量函数调用的信息，这样可以重新编写代码转而使用循环，或者使用尾递归。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">3.1 首先调用了greet函数，函数未执行完成，又调用了greet2函数</span><br><span class="hljs-string">3.2 栈溢出。栈将不断地增大。每个程序可使用的调用栈空间都有限，</span><br><span class="hljs-string">    程序用完这些空间（终将如此）后，将因栈溢出而终止。</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h1 id="快速排序">4 快速排序</h1>
<h2 id="分而治之divide-and-conquer-dc">分而治之（divide and conquer, D&amp;C）</h2>
<p>使用D&amp;C解决问题的两个步骤</p>
<ul>
<li>找出基线条件，这种条件必须尽可能简单</li>
<li>不断将问题分解（或者说所小规模），直到符合基线条件</li>
</ul>
<p>练习</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 4.1 循环</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span>(<span class="hljs-params">arr</span>):</span><br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>        total += i<br>    <span class="hljs-keyword">return</span> total<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>([<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 4.1 递归</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">if</span> arr == []: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] + <span class="hljs-built_in">sum</span>(arr[<span class="hljs-number">1</span>:])<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]))<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 4.2</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num_of_items</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">if</span> arr == []: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + num_of_items(arr[<span class="hljs-number">1</span>:])<br><br><span class="hljs-built_in">print</span>(num_of_items([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]))<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 4.3</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span>(<span class="hljs-params"><span class="hljs-built_in">list</span></span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>) == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>] &gt; <span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>]<br>    sub_max = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>] &gt; sub_max <span class="hljs-keyword">else</span> sub_max<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]))<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 基线条件是数组中只剩一个元素。</span><br><span class="hljs-comment"># 递归条件是将数组分成两半，将其中一半丢弃，再对另一半执行二分查找</span><br></code></pre></td></tr></table></figure>
<h2 id="快速排序-1">快速排序</h2>
<p>快速排序的工作原理</p>
<ul>
<li>首先，从数组中选择一个元素作为基准值（pivot）</li>
<li>然后，找出比基准值小的元素以及比基准值大的元素，这一步叫分区，数组被分成三分
<ul>
<li>一个所有小于基准值的数构成的子数组</li>
<li>基准值</li>
<li>一个所有大于基准值的数构成的子数组</li>
</ul></li>
<li>递归</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 快速排序算法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quicksort</span>(<span class="hljs-params">array</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(array) &lt; <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> array<br>    <span class="hljs-keyword">else</span>:<br>        pivot = array[<span class="hljs-number">0</span>]<br>        less = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt;= pivot]<br>        greater = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &gt;= pivot]<br>        <span class="hljs-keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)<br><br><span class="hljs-built_in">print</span>(quicksort([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure>
<h2 id="再谈大o表示法">再谈大O表示法</h2>
<p>快速排序和合并排序比较</p>
<ul>
<li>快速排序的平均运行时间为<span class="math inline">\(O(n\ log\ n)\)</span>，最糟糕情况为<span class="math inline">\(O(n^2)\)</span></li>
<li>快速排序的常量比合并排序的常量小</li>
<li>快速排序遇到平均情况的可能性比最糟糕情况大的多</li>
<li>因此，快速查找一般更快</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">4.5 O(n)</span><br><span class="hljs-string">4.6 O(n)</span><br><span class="hljs-string">4.7 O(1)</span><br><span class="hljs-string">4.8 O(n^2)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h1 id="散列表hash-tables">5 散列表（Hash Tables）</h1>
<h2 id="散列函数hash哈希函数">散列函数（Hash哈希函数）</h2>
<p>散列函数是将输入映射到数字的函数。散列表也使用数组来存储数据。Python提供的散列表实现为字典。散列表是无序的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">5.1 是</span><br><span class="hljs-string">5.2 否</span><br><span class="hljs-string">5.3 否</span><br><span class="hljs-string">5.4 是</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="应用案例">应用案例</h2>
<h3 id="用于查找">用于查找</h3>
<p>模拟映射关系，将键映射到值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">phone_book = &#123;&#125;<br>phone_book[<span class="hljs-string">&quot;Jenny&quot;</span>] = <span class="hljs-number">238725</span><br>phone_book[<span class="hljs-string">&quot;Emergency&quot;</span>] = <span class="hljs-number">911</span><br><span class="hljs-built_in">print</span>(phone_book[<span class="hljs-string">&quot;Emergency&quot;</span>])<br></code></pre></td></tr></table></figure>
<h3 id="防止重复">防止重复</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_voter</span>(<span class="hljs-params">name</span>):</span><br>    voted = &#123;&#125;<br>    voted[<span class="hljs-string">&quot;abc&quot;</span>] = <span class="hljs-number">123</span><br>    <span class="hljs-keyword">if</span> voted.get(name): <span class="hljs-comment"># dict.get(key,default=None)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Kick them out!&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Let the vote&quot;</span>)<br><br>check_voter(<span class="hljs-string">&quot;abc&quot;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="用作缓存">用作缓存</h3>
<p>缓存的数据存储在散列表中。网站一般将页面url映射到页面数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">cache = &#123;&#125;<br>cache[<span class="hljs-string">&quot;https://babblingme.gitee.io&quot;</span>] = <span class="hljs-number">123</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_page</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-keyword">if</span> cache.get(url):<br>        <span class="hljs-keyword">return</span> cache[url]<br>    <span class="hljs-keyword">else</span>:<br>        data = get_data_from_server(url)<br>        cache[url] = data<br>        <span class="hljs-keyword">return</span> data<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data_from_server</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is data&quot;</span><br><br><span class="hljs-built_in">print</span>(get_page(<span class="hljs-string">&quot;https://babblingme.gitee.io&quot;</span>))<br></code></pre></td></tr></table></figure>
<h2 id="冲突与性能">冲突与性能</h2>
<p>在同一位置处存储不同的键值对就会产生冲突，需要在该位置处添加指向另一位置处的链表解决冲突。如果链表很长就会影响性能。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>散列表（平均）</th>
<th>散列表（最坏）</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>查找</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr class="even">
<td>插入</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr class="odd">
<td>删除</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>要避免冲突，需要有较低的装填因子和良好的散列函数。</p>
<p>装填因子=数列表包含的元素数/位置总数。装填因子度量的是散列表中有多少位置是空的。一旦装填因子增大（一般大于0.7就需要调整，大于1意味着有些位置会有两个键值，就需要创建链表），就需要在散列表中添加位置，即调整长度。</p>
<p>良好的散列函数让数组中的值呈均匀分布。糟糕的散列函数让值扎堆，导致大量冲突。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string"># 感觉答案不太对头</span><br><span class="hljs-string">5.5 D</span><br><span class="hljs-string">5.6 B</span><br><span class="hljs-string">5.7 CD</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h1 id="广度优先搜索breadth-first-search">6 广度优先搜索（Breadth-First Search）</h1>
<h2 id="图简介">图简介</h2>
<p>解决最短路径问题（shorterst-path problem）的算法被称为广度优先搜索。需要两个步骤</p>
<ul>
<li>使用图来建立问题模型</li>
<li>使用广度优先搜索解决问题</li>
</ul>
<p>图模拟一组连接。图由节点（node）和边（edge）组成，一个节点可能与众多节点直接相连，这些节点被称为邻居。</p>
<h2 id="广度优先搜索">广度优先搜索</h2>
<p>广度优先搜索是一种用于图的查找算法，可以帮助回答两类问题</p>
<ul>
<li>从节点A出发，有前往节点B的路径吗？</li>
<li>从节点A出发，前往节点B的哪条路径最短？</li>
</ul>
<p>广度优先搜索先检查一度关系，再检查二度关系。</p>
<p>实现按添加顺序检查的数据结构就是队列（queue）。队列类似于栈，不能随机地访问队列中的元素。队列只支持两种操作：入队和出队。队列是一种先进先出（First In First Out，FIFO）的数据结构，而栈是一种后进先出（Last In First Out，LIFO）的数据结构。可以比较形象的理解为，队列是前后堆叠，而栈是上下堆叠。</p>
<h3 id="实现图">实现图</h3>
<p><img src="/ass/20220104-map.png" srcset="/img/loading.gif" lazyload /></p>
<p>Anuj、Peggy、Thom和Jonny都没有邻居，这是因为虽然有指向它们的箭头但是没有从它们出发指向别人的箭头，这种叫有向图（directed graph），其关系是单向的。因此Anuj是Bob的邻居，但Bob不是Anuj的邻居。无向图（undirected graph）没有箭头，直接相连的节点互为邻居。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">graph = &#123;&#125;<br>graph[<span class="hljs-string">&quot;You&quot;</span>] = [<span class="hljs-string">&quot;alice&quot;</span>,<span class="hljs-string">&quot;bob&quot;</span>,<span class="hljs-string">&quot;claire&quot;</span>] <span class="hljs-comment"># you被映射到一个包含其所有邻居的数组</span><br>graph[<span class="hljs-string">&quot;bob&quot;</span>] = [<span class="hljs-string">&quot;anuj&quot;</span>,<span class="hljs-string">&quot;peggy&quot;</span>]<br>graph[<span class="hljs-string">&quot;alice&quot;</span>] = [<span class="hljs-string">&quot;peggy&quot;</span>]<br>graph[<span class="hljs-string">&quot;claire&quot;</span>] = [<span class="hljs-string">&quot;jonny&quot;</span>,<span class="hljs-string">&quot;thom&quot;</span>]<br>graph[<span class="hljs-string">&quot;anuj&quot;</span>] = []<br>graph[<span class="hljs-string">&quot;peggy&quot;</span>] = []<br>graph[<span class="hljs-string">&quot;thom&quot;</span>] = []<br>graph[<span class="hljs-string">&quot;jonny&quot;</span>] = []<br><span class="hljs-comment"># 散列表是无序的，因此添加键值对的顺序无关紧要</span><br><span class="hljs-comment"># 但是后面的搜索列表必须要按先后顺序进行搜索，所以采用队列</span><br></code></pre></td></tr></table></figure>
<h3 id="实现算法">实现算法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">person_is_seller</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">return</span> name[-<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;m&quot;</span> <span class="hljs-comment"># 最后一个字母是m返回真</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">name</span>):</span><br>    search_queue = deque() <span class="hljs-comment"># 创建双端队列，搜索列表必须是队列，以保证按加入顺序搜索列表中的人</span><br>    search_queue += graph[name]<br>    searched = []<br>    <span class="hljs-keyword">while</span> search_queue:<br>        person = search_queue.popleft() <span class="hljs-comment"># pop用于stack，popleft用于collections</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> person <span class="hljs-keyword">in</span> searched: <span class="hljs-comment"># 对于检查过的人不必重复检查</span><br>            <span class="hljs-keyword">if</span> person_is_seller(person):<br>                <span class="hljs-built_in">print</span>(person+<span class="hljs-string">&quot; is a mango seller!&quot;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                search_queue += graph[person]<br>                searched.append(person)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No mango seller&quot;</span>)<br><br>search(<span class="hljs-string">&quot;claire&quot;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="运行时间">运行时间</h3>
<p>广度优先搜索的运行时间是O(人数+边数)，O(V+E)，V是顶点数vertice，E是边数edge。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">6.3 B可行</span><br><span class="hljs-string">6.4 # 拓扑排序，A任务依赖于B，在列表中A就必须在B后边</span><br><span class="hljs-string">1) 起床</span><br><span class="hljs-string">2) 锻炼</span><br><span class="hljs-string">3) 刷牙</span><br><span class="hljs-string">4) 打包午餐</span><br><span class="hljs-string">5) 洗澡</span><br><span class="hljs-string">6) 吃早餐</span><br><span class="hljs-string">7) 穿衣服</span><br><span class="hljs-string">6.5 AC # 树是图的子集</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h1 id="迪克斯特拉算法">7 迪克斯特拉算法</h1>
<h2 id="简介">简介</h2>
<p>带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。广度优先搜索可计算非加权图中的最短路径。迪克斯特拉算法（Dijkstra's algorithm）可计算加权图中的最短（也就是最快，或总权重最小）路径。</p>
<p>从一个节点出发，走一圈后又回到这个节点，这就是一个环。环增加了权重，绕环的路径不可能是最短路径。无向图是两个节点彼此指向对方，其实就是环。在无向图中，每条边都是一个环。迪克斯特拉算法只适用于有向无环图（directed acyclic graph, DAG）。</p>
<p>迪克斯特拉算法的四个步骤：</p>
<ul>
<li>找出最便宜的节点，即可在最短时间内前往的节点。</li>
<li>对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。</li>
<li>重复这个过程，直到对图中的每个节点都这样做了（除终点）。</li>
<li>计算最终路径。</li>
</ul>
<h2 id="换钢琴">换钢琴</h2>
<p>Rama，想拿一本乐谱换架钢琴。</p>
<p>Alex说：“这是我最喜欢的乐队Destroyer的海报，我愿意拿它换你的乐谱。如果你再加5美元，还可拿乐谱换我这张稀有的Rick Astley黑胶唱片。”</p>
<p>Amy说：“哇，我听说这张黑胶唱片里有首非常好听的歌曲，我愿意拿我的吉他或架子鼓换这张海报或黑胶唱片。”</p>
<p>Beethoven惊呼：“我一直想要吉他，我愿意拿我的钢琴换Amy的吉他或架子鼓。“</p>
<p><img src="/ass/20220105-piano.png" srcset="/img/loading.gif" lazyload /></p>
<table>
<thead>
<tr class="header">
<th>父节点</th>
<th>节点</th>
<th>开销</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>乐谱</strong></td>
<td><strong>黑胶唱片</strong></td>
<td><strong>5</strong></td>
</tr>
<tr class="even">
<td><strong><em>乐谱</em></strong></td>
<td><strong><em>海报</em></strong></td>
<td><strong><em>0</em></strong></td>
</tr>
<tr class="odd">
<td>-</td>
<td>低音吉他</td>
<td><span class="math inline">\(\infty\)</span></td>
</tr>
<tr class="even">
<td>-</td>
<td>架子鼓</td>
<td><span class="math inline">\(\infty\)</span></td>
</tr>
<tr class="odd">
<td>-</td>
<td>钢琴</td>
<td><span class="math inline">\(\infty\)</span></td>
</tr>
</tbody>
</table>
<p>注：无穷大代表暂时不知道如何从起点前往这些节点。</p>
<ul>
<li><p>第一步：找出最便宜的节点。换海报最便宜</p></li>
<li><p>第二步：计算前往该节点的各个邻居的开销。</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th>父节点</th>
<th>节点</th>
<th>开销</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>乐谱</td>
<td>黑胶唱片</td>
<td>5</td>
</tr>
<tr class="even">
<td>乐谱</td>
<td>海报</td>
<td>0</td>
</tr>
<tr class="odd">
<td><strong><em>海报</em></strong></td>
<td><strong><em>低音吉他</em></strong></td>
<td><strong><em>30</em></strong></td>
</tr>
<tr class="even">
<td><strong>海报</strong></td>
<td><strong>架子鼓</strong></td>
<td><strong>35</strong></td>
</tr>
<tr class="odd">
<td>-</td>
<td>钢琴</td>
<td><span class="math inline">\(\infty\)</span></td>
</tr>
</tbody>
</table>
<ul>
<li>再执行第一步：下一个最便宜的节点是黑胶唱片——需要额外支付5美元。</li>
<li>再执行第二部：更新黑胶唱片的各个邻居的开销。</li>
</ul>
<table>
<thead>
<tr class="header">
<th>父节点</th>
<th>节点</th>
<th>开销</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>乐谱</td>
<td>黑胶唱片</td>
<td>5</td>
</tr>
<tr class="even">
<td>乐谱</td>
<td>海报</td>
<td>0</td>
</tr>
<tr class="odd">
<td><strong><em>黑胶唱片</em></strong></td>
<td><strong><em>低音吉他</em></strong></td>
<td><strong><em>20</em></strong></td>
</tr>
<tr class="even">
<td><strong>黑胶唱片</strong></td>
<td><strong>架子鼓</strong></td>
<td><strong>25</strong></td>
</tr>
<tr class="odd">
<td>-</td>
<td>钢琴</td>
<td><span class="math inline">\(\infty\)</span></td>
</tr>
</tbody>
</table>
<p>注：开销价格为途径的总价格。经“黑胶唱片”前往“低音吉他”和“架子鼓”的开销比经“海报”前往这两个节点要低。所以将这两个节点的父节点改为“黑胶唱片”</p>
<p>最便宜的是低音吉他，先更新其开销</p>
<table>
<thead>
<tr class="header">
<th>父节点</th>
<th>节点</th>
<th>开销</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>乐谱</td>
<td>黑胶唱片</td>
<td>5</td>
</tr>
<tr class="even">
<td>乐谱</td>
<td>海报</td>
<td>0</td>
</tr>
<tr class="odd">
<td>黑胶唱片</td>
<td>低音吉他</td>
<td>20</td>
</tr>
<tr class="even">
<td>黑胶唱片</td>
<td>架子鼓</td>
<td>25</td>
</tr>
<tr class="odd">
<td><strong><em>低音吉他</em></strong></td>
<td><strong><em>钢琴</em></strong></td>
<td><strong><em>40</em></strong></td>
</tr>
</tbody>
</table>
<p>然后未处理节点中最便宜的是架子鼓，更新其开销</p>
<table>
<thead>
<tr class="header">
<th>父节点</th>
<th>节点</th>
<th>开销</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>乐谱</td>
<td>黑胶唱片</td>
<td>5</td>
</tr>
<tr class="even">
<td>乐谱</td>
<td>海报</td>
<td>0</td>
</tr>
<tr class="odd">
<td>黑胶唱片</td>
<td>低音吉他</td>
<td>20</td>
</tr>
<tr class="even">
<td>黑胶唱片</td>
<td>架子鼓</td>
<td>25</td>
</tr>
<tr class="odd">
<td><strong><em>架子鼓</em></strong></td>
<td><strong><em>钢琴</em></strong></td>
<td><strong><em>35</em></strong></td>
</tr>
</tbody>
</table>
<p>这里经架子鼓到达钢琴开销更低，因此更新钢琴父节点为架子鼓。最终路径就可以确定下来了</p>
<p>钢琴的父节点是架子鼓，架子鼓的父节点是黑胶唱片，黑胶唱片的父节点是乐谱。</p>
<h2 id="负权边">负权边</h2>
<p>迪克斯特拉算法假设：对于处理过的海报节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立。因此，不能将迪克斯特拉算法用于包含负权边的图。包含负权边的图，可以用贝尔曼-福德算法（Bellman-Ford algorithm）。</p>
<h2 id="算法实现">算法实现</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 散列表-图</span><br>graph = &#123;&#125;<br>graph[<span class="hljs-string">&quot;start&quot;</span>] = &#123;&#125;<br>graph[<span class="hljs-string">&quot;start&quot;</span>][<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">6</span><br>graph[<span class="hljs-string">&quot;start&quot;</span>][<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-number">2</span><br>graph[<span class="hljs-string">&quot;a&quot;</span>] = &#123;&#125;<br>graph[<span class="hljs-string">&quot;a&quot;</span>][<span class="hljs-string">&quot;fin&quot;</span>] = <span class="hljs-number">1</span><br>graph[<span class="hljs-string">&quot;b&quot;</span>] = &#123;&#125;<br>graph[<span class="hljs-string">&quot;b&quot;</span>][<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">3</span><br>graph[<span class="hljs-string">&quot;b&quot;</span>][<span class="hljs-string">&quot;fin&quot;</span>] = <span class="hljs-number">5</span><br>graph[<span class="hljs-string">&quot;fin&quot;</span>] = &#123;&#125;<br><br><span class="hljs-comment"># 散列表-开销</span><br>infinity = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>costs = &#123;&#125;<br>costs[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">6</span><br>costs[<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-number">2</span><br>costs[<span class="hljs-string">&quot;fin&quot;</span>] = infinity<br><br><span class="hljs-comment"># 散列表-父节点</span><br>parents = &#123;&#125;<br>parents[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;start&quot;</span><br>parents[<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-string">&quot;start&quot;</span><br>parents[<span class="hljs-string">&quot;fin&quot;</span>] = <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 数组-处理过的节点</span><br>processed = []<br><br><span class="hljs-comment"># 找到最小开销的节点</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_lowest_cost_node</span>(<span class="hljs-params">costs</span>):</span><br>    lowest_cost = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>    lowest_cost_node = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> costs:<br>        cost = costs[node]<br>        <span class="hljs-keyword">if</span> cost &lt; lowest_cost <span class="hljs-keyword">and</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> processed:<br>            lowest_cost = cost<br>            lowest_cost_node = node<br>    <span class="hljs-keyword">return</span> lowest_cost_node<br><br><span class="hljs-comment"># 迪克斯特拉算法</span><br>node = find_lowest_cost_node(costs) <span class="hljs-comment"># 找出开销最低的节点</span><br><span class="hljs-keyword">while</span> node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    cost = costs[node] <span class="hljs-comment"># 获取该节点的开销及邻居</span><br>    neighbors = graph[node]<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> neighbors.keys(): <span class="hljs-comment"># 遍历邻居</span><br>        new_cost = cost + neighbors[n] <span class="hljs-comment"># 新开销</span><br>        <span class="hljs-keyword">if</span> costs[n] &gt; new_cost: <span class="hljs-comment"># 新旧开销对比</span><br>            costs[n] = new_cost <span class="hljs-comment"># 新开销更低就更新开销</span><br>            parents[n] = node <span class="hljs-comment"># 更新父节点</span><br>    processed.append(node)<br>    node = find_lowest_cost_node(costs)<br><span class="hljs-built_in">print</span>(parents)<br></code></pre></td></tr></table></figure>
<p>练习题，顺便简化了散列表的创建</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">7.1 A 8, B 60, C 4 但无法用迪克斯特拉算法求解</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># 7.1 A</span><br><span class="hljs-comment">#######################直接创建字典</span><br><span class="hljs-comment"># 散列表-图</span><br>graph = &#123;<span class="hljs-string">&quot;start&quot;</span>:&#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-number">2</span>&#125;,<span class="hljs-string">&quot;a&quot;</span>:&#123;<span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;d&quot;</span>:<span class="hljs-number">4</span>&#125;,<br>        <span class="hljs-string">&quot;b&quot;</span>:&#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">8</span>,<span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-number">7</span>&#125;,<span class="hljs-string">&quot;c&quot;</span>:&#123;<span class="hljs-string">&quot;fin&quot;</span>:<span class="hljs-number">1</span>&#125;,<br>        <span class="hljs-string">&quot;d&quot;</span>:&#123;<span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-number">6</span>,<span class="hljs-string">&quot;fin&quot;</span>:<span class="hljs-number">3</span>&#125;,<span class="hljs-string">&quot;fin&quot;</span>:&#123;&#125;&#125;<br><br><span class="hljs-comment"># 散列表-开销</span><br>infinity = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>costs = &#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;c&quot;</span>:infinity,<span class="hljs-string">&quot;d&quot;</span>:infinity,<span class="hljs-string">&quot;fin&quot;</span>:infinity&#125;<br><br><span class="hljs-comment"># 散列表-父节点</span><br>parents = &#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-string">&quot;start&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-string">&quot;start&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-literal">None</span>,<span class="hljs-string">&quot;d&quot;</span>:<span class="hljs-literal">None</span>,<span class="hljs-string">&quot;fin&quot;</span>:<span class="hljs-literal">None</span>&#125;<br><br><span class="hljs-comment"># 数组-处理过的节点</span><br>processed = []<br><span class="hljs-comment">##############################调用迪克斯特拉算法</span><br><span class="hljs-built_in">print</span>(parents)<br><span class="hljs-comment"># 输出结果： &#123;&#x27;a&#x27;: &#x27;start&#x27;, &#x27;b&#x27;: &#x27;start&#x27;, &#x27;c&#x27;: &#x27;a&#x27;, &#x27;d&#x27;: &#x27;a&#x27;, &#x27;fin&#x27;: &#x27;c&#x27;&#125;</span><br><span class="hljs-comment"># 通过父节点推断除最短路径，fin-&gt;c-&gt;a-&gt;start，然后权重相加得到8</span><br></code></pre></td></tr></table></figure>
<h1 id="贪婪算法贪心算法">8 贪婪算法（贪心算法）</h1>
<h2 id="教室调度和背包问题">教室调度和背包问题</h2>
<p>贪婪算法：每步都选择局部最优解，得到的就是全局最优解。</p>
<p>有如下课表，将尽可能多的课程安排在一间教室</p>
<p><img src="/ass/20220105-class.png" srcset="/img/loading.gif" lazyload /></p>
<ul>
<li>选出结束最早的课，也就是这间教室上的第一节课。</li>
<li>然后选择第一节课结束之后才开始的课。重复以上步骤就可以了。</li>
</ul>
<p>小偷背着可装入一定重量的背包，在商场盗窃各种商品装入背包，如何利益最大化</p>
<ul>
<li>盗窃可装入背包的最贵商品</li>
<li>再盗窃还可装入背包的最贵商品，以此类推。</li>
</ul>
<p>这样贪婪算法找到的并不是最优解，只是接近最优解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">8.1 1)找到最大程度贴合卡车尺寸的箱子，2)在装入能装入卡车的最大尺寸的箱子。不能</span><br><span class="hljs-string">8.2 1)找出最大价值的旅行，2)找出剩余天数内能进行的最大价值旅行。不能</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="集合覆盖问题set-covering-problem">集合覆盖问题（set covering problem）</h2>
<ul>
<li>列出每个可能的广播台集合，这被称为幂集（power set），可能的子集有2<sup>2</sup>个（<a target="_blank" rel="noopener" href="https://www.shuxuele.com/sets/power-set.html">详见</a>）。</li>
<li>在这些集合中，选出覆盖全美50个州的最小集合。</li>
</ul>
<p>因为有2<sup>n</sup>个可能的集合，所以运行时间为<span class="math inline">\(O(2^n)\)</span>。运行时间太长了。可以通过贪婪算法近似求解。</p>
<h3 id="近似算法">近似算法</h3>
<ul>
<li>选出一个覆盖最多未覆盖州的广播台。</li>
<li>重复第一步，直到覆盖了所有州。</li>
</ul>
<p>这是一种近似算法（approximation algorithm），在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下：</p>
<ul>
<li>速度有多快。</li>
<li>得到的近似解与最优解的接近程度。</li>
</ul>
<p>在上个例子中，贪婪算法的运行时间为<span class="math inline">\(O(n^2)\)</span>，其中<span class="math inline">\(n\)</span>为广播台数量。下面看看解决在这个问题的代码，这里做了简化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 近似算法</span><br>states_needed = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;mt&quot;</span>,<span class="hljs-string">&quot;wa&quot;</span>,<span class="hljs-string">&quot;or&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;nv&quot;</span>,<span class="hljs-string">&quot;ut&quot;</span>,<span class="hljs-string">&quot;ca&quot;</span>,<span class="hljs-string">&quot;az&quot;</span>]) <span class="hljs-comment"># 需要覆盖的州。这是集合，类似于列表，但集合不能包含重复的元素</span><br>stations = &#123;&#125;<br>stations[<span class="hljs-string">&quot;knoe&quot;</span>] = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;nv&quot;</span>,<span class="hljs-string">&quot;ut&quot;</span>])<br>stations[<span class="hljs-string">&quot;ktwo&quot;</span>] = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;wa&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;mt&quot;</span>])<br>stations[<span class="hljs-string">&quot;kthree&quot;</span>] = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;or&quot;</span>,<span class="hljs-string">&quot;nv&quot;</span>,<span class="hljs-string">&quot;ca&quot;</span>])<br>stations[<span class="hljs-string">&quot;kfour&quot;</span>] = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;nv&quot;</span>,<span class="hljs-string">&quot;ut&quot;</span>])<br>stations[<span class="hljs-string">&quot;kfive&quot;</span>] = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;ca&quot;</span>,<span class="hljs-string">&quot;az&quot;</span>])<br>finall_stations = <span class="hljs-built_in">set</span>()<br><br><span class="hljs-keyword">while</span> states_needed:<br>    best_station = <span class="hljs-literal">None</span> <span class="hljs-comment"># 可覆盖最多未覆盖州的广播台</span><br>    states_covered = <span class="hljs-built_in">set</span>() <span class="hljs-comment"># 包含该广播台覆盖的所有未覆盖州</span><br>    <span class="hljs-keyword">for</span> station, states <span class="hljs-keyword">in</span> stations.items(): <span class="hljs-comment"># 取出stations的两个元素（键值），第一个是广播台，第二个是该广播台覆盖的州</span><br>        covered = states_needed &amp; states<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(covered) &gt; <span class="hljs-built_in">len</span>(states_covered): <span class="hljs-comment"># 只有没完全覆盖就进入循环</span><br>            best_station = station<br>            states_covered = covered<br>    states_needed -= states_covered <span class="hljs-comment"># 减掉以覆盖州</span><br>    finall_stations.add(best_station) <span class="hljs-comment"># 选出来的最适合的广播台（每次运行结果不一样）</span><br><br><span class="hljs-built_in">print</span>(finall_stations)<br></code></pre></td></tr></table></figure>
<p>交集、差集和并集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;avocado&quot;</span>,<span class="hljs-string">&quot;tomato&quot;</span>,<span class="hljs-string">&quot;banana&quot;</span>])<br>vegetables = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;beets&quot;</span>,<span class="hljs-string">&quot;carrots&quot;</span>,<span class="hljs-string">&quot;tomato&quot;</span>])<br>test = fruits - vegetables <span class="hljs-comment"># 交集&amp;，并集|，差集-（差集是剔除前者集合中后者集合含有的元素）</span><br><span class="hljs-built_in">print</span>(test)<br></code></pre></td></tr></table></figure>
<p>练习题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">8.3 不是</span><br><span class="hljs-string">8.4 是，贪心算法是先找到局部最优解，而广度优先搜索及迪克斯特拉算法每一步都是找到最短路径（局部最优解），因此属于贪心算法。</span><br><span class="hljs-string">8.5 是</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="np完全问题">NP完全问题</h2>
<p>旅行商问题和集合覆盖问题有一些共同指出：需要计算所有解，并从中挑出最小/最短的那个。这两个问题都属于NP完全问题。NP完全问题的意思是多项式复杂程度的非确定性问题（Non-deterministic Polynomial Complete），其简单定义就是以难解著称的问题。NP完全问题基本不可能快速求解，只能近似求解。贪婪算法是不错的近似算法。</p>
<h3 id="如何识别np完全问题">如何识别NP完全问题</h3>
<p>无法直接判断问题是不是NP完全问题，只有一些细节值得注意</p>
<ul>
<li>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</li>
<li>涉及“所有组合”的问题通常是NP完全问题。</li>
<li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li>
<li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li>
<li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li>
<li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li>
</ul>
<p>练习题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">8.6 是，经由几个点的最短路径问题，就是旅行商问题</span><br><span class="hljs-string">8.7 是，集合覆盖问题？</span><br><span class="hljs-string">8.8 是，集合覆盖问题</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h1 id="动态规划">9 动态规划</h1>
<h2 id="背包问题">背包问题</h2>
<p>小偷背着一个可装4磅东西的背包，可盗窃的商品有：</p>
<table>
<thead>
<tr class="header">
<th>商品</th>
<th>价格</th>
<th>重量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>音响</td>
<td>3000美元</td>
<td>4磅</td>
</tr>
<tr class="even">
<td>笔记本电脑</td>
<td>2000美元</td>
<td>3磅</td>
</tr>
<tr class="odd">
<td>吉他</td>
<td>1500美元</td>
<td>1磅</td>
</tr>
</tbody>
</table>
<p>如何让盗取的商品价值最高？</p>
<h3 id="简单算法">简单算法</h3>
<p>排列组合有2<sup>n</sup>种情况，运行时间太慢，贪心算法可以得到近似解，但不一定是最优解。</p>
<h3 id="动态规划-1">动态规划</h3>
<p>动态规划先解决子问题，再逐步解决大问题。每个动态规划算法都从一个网格开始，背包问题的网格如下。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>吉他</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
</tr>
<tr class="even">
<td>音响</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
<td>3000S</td>
</tr>
<tr class="odd">
<td>笔记本电脑</td>
<td>1500G</td>
<td>1500G</td>
<td><strong>2000L</strong></td>
<td><strong><em>3500L G</em></strong></td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cell[i][j] = cell[i-<span class="hljs-number">1</span>][j] <span class="hljs-keyword">or</span> value + cell[i-<span class="hljs-number">1</span>][j-weight] <span class="hljs-comment"># value是当前商品的价值，weight是当前商品重量</span><br><span class="hljs-comment"># 当前单元格的值=上一个单元格的值 或者 当前商品的价值+剩余空间的价值</span><br></code></pre></td></tr></table></figure>
<h2 id="背包问题faq">背包问题FAQ</h2>
<ul>
<li>4件商品</li>
</ul>
<p>第4件商品iPhone：2000美元，1磅</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>吉他</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
</tr>
<tr class="even">
<td>音响</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
<td>3000S</td>
</tr>
<tr class="odd">
<td>笔记本电脑</td>
<td>1500G</td>
<td>1500G</td>
<td>2000L</td>
<td>3500L G</td>
</tr>
<tr class="even">
<td>iPhone</td>
<td><strong>2000I</strong></td>
<td><strong>3500G I</strong></td>
<td><strong>3500G I</strong></td>
<td><strong><em>4000L I</em></strong></td>
</tr>
</tbody>
</table>
<ul>
<li>5件商品</li>
</ul>
<p>第5件商品MP3：1000美元，1磅</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>吉他</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
</tr>
<tr class="even">
<td>音响</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
<td>3000S</td>
</tr>
<tr class="odd">
<td>笔记本电脑</td>
<td>1500G</td>
<td>1500G</td>
<td>2000L</td>
<td>3500L G</td>
</tr>
<tr class="even">
<td>iPhone</td>
<td>2000I</td>
<td>3500G I</td>
<td>3500G I</td>
<td>4000L I</td>
</tr>
<tr class="odd">
<td>MP3</td>
<td>2000I</td>
<td>3500G I</td>
<td>3500G I</td>
<td>4000L I</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 9.1 不偷</span><br></code></pre></td></tr></table></figure>
<ul>
<li>行的排列顺序发生变化</li>
</ul>
<p>行的排列顺序发生变化时，最终答案不变，即各行的排列顺序无关紧要。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>音响</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>3000S</td>
</tr>
<tr class="even">
<td>笔记本电脑</td>
<td>-</td>
<td>-</td>
<td>2000L</td>
<td>3000S</td>
</tr>
<tr class="odd">
<td>吉他</td>
<td>1500G</td>
<td>1500G</td>
<td>2000L</td>
<td>3500G L</td>
</tr>
</tbody>
</table>
<p>逐列填充网格可能会有影响</p>
<ul>
<li>增加一件更小的商品</li>
</ul>
<p>比如一条项链：1000美元，0.5磅。这需要将网格细化，每列最小刻度为0.5。</p>
<ul>
<li>偷商品的一部分</li>
</ul>
<p>动态规划没办法处理连续性问题，只能处理分立问题。这种情况可以用贪婪算法处理。（1）尽可能多的拿价值最高的商品，（2）如果拿光了，再尽可能多的拿价值次高的商品，以此类推。</p>
<ul>
<li>旅游行程最优化</li>
</ul>
<p>你有两天假期，旅游地点及时间如下</p>
<table>
<thead>
<tr class="header">
<th>名胜</th>
<th>时间</th>
<th>评分</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>威斯敏斯特教堂</td>
<td>0.5天</td>
<td>7</td>
</tr>
<tr class="even">
<td>环球剧场</td>
<td>0.5天</td>
<td>6</td>
</tr>
<tr class="odd">
<td>英国国家美术馆</td>
<td>1天</td>
<td>9</td>
</tr>
<tr class="even">
<td>大英博物馆</td>
<td>2天</td>
<td>9</td>
</tr>
<tr class="odd">
<td>圣保罗大教堂</td>
<td>0.5天</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>如何确定旅游行程？绘制动态规划网格如下</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>0.5</th>
<th>1</th>
<th>1.5</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>威斯敏斯特教堂W</td>
<td>7W</td>
<td>7W</td>
<td>7W</td>
<td>7W</td>
</tr>
<tr class="even">
<td>环球剧场T</td>
<td>7W</td>
<td>13W T</td>
<td>13W T</td>
<td>13W T</td>
</tr>
<tr class="odd">
<td>英国国家美术馆A</td>
<td>7W</td>
<td>13W T</td>
<td>16W A</td>
<td>22W A T</td>
</tr>
<tr class="even">
<td>大英博物馆</td>
<td>7W</td>
<td>13W T</td>
<td>16W A</td>
<td>22W A T</td>
</tr>
<tr class="odd">
<td>圣保罗大教堂S</td>
<td>8S</td>
<td>15W S</td>
<td>17S A</td>
<td>24W S A</td>
</tr>
</tbody>
</table>
<p>旅游行程为：威斯敏斯特教堂-&gt;圣保罗大教堂-&gt;英国国家美术馆</p>
<ul>
<li>处理相互依赖的情况</li>
</ul>
<p>仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。</p>
<ul>
<li>计算最终的解时不会涉及两个以上子背包</li>
</ul>
<p>最多只需要合并两个子背包，即根本不会涉及两个以上的子背包。不过这些子背包可能又包含子背包。</p>
<ul>
<li>最优解可能导致背包没装满</li>
</ul>
<p>练习9.2</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>水W</td>
<td>-</td>
<td>-</td>
<td>10W</td>
<td>10W</td>
<td>10W</td>
<td>10W</td>
</tr>
<tr class="even">
<td>书B</td>
<td>3B</td>
<td>3B</td>
<td>10W</td>
<td>13BW</td>
<td>13BW</td>
<td>13BW</td>
</tr>
<tr class="odd">
<td>食物F</td>
<td>3B</td>
<td>9F</td>
<td>12FB</td>
<td>13BW</td>
<td>19FW</td>
<td>22FBW</td>
</tr>
<tr class="even">
<td>夹克J</td>
<td>3B</td>
<td>9F</td>
<td>12FB</td>
<td>14JW</td>
<td>19FW</td>
<td>22FBW</td>
</tr>
<tr class="odd">
<td>相机C</td>
<td>6C</td>
<td>9CB</td>
<td>15CF</td>
<td>18CFB</td>
<td>20CJF</td>
<td>25CFW</td>
</tr>
</tbody>
</table>
<p>应该带水、食物和相机</p>
<h2 id="最长公共子串">最长公共子串</h2>
<p>费曼算法（滑稽）</p>
<ul>
<li>将问题写下来</li>
<li>好好思考</li>
<li>将答案写下来</li>
</ul>
<p>一个输错的单词hish，更像fish还是fosh？</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>h</th>
<th>i</th>
<th>s</th>
<th>h</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>f</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>i</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>s</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr class="even">
<td>h</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> word_a[i] == word_b[j]:<br>    cell[i][j] = cell[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>    cell[i][j] = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>最长公共子串：两个字符串中连续相同的部分。</p>
<p>最长公共子序列：两个字符串中都有的序列包含的字母数。</p>
<p>两者的区别是：子串要求在原字符串中是连续的，而子序列则只需保持相对顺序，并不要求连续。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>f</th>
<th>o</th>
<th>s</th>
<th>h</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>f</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>i</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>s</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>h</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> word_a[i] == word_b[j]:<br>    cell[i][j] = cell[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>    cell[i][j] = <span class="hljs-built_in">max</span>(cell[i-<span class="hljs-number">1</span>][j], cell[i][j-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>
<p>练习9.3</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>b</th>
<th>l</th>
<th>u</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>c</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>l</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>u</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr class="even">
<td>e</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
<tr class="odd">
<td>s</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>动态规划的实际应用</p>
<ul>
<li>根据最长公共序列确定DNA链的相似性。</li>
<li><code>git diff</code>指出两个文件的差异。</li>
<li>编辑距离（levenshtein distance）指出两个字符串的相似程度，使用了动态规划。编辑距离算法用于拼写检查，判断用户上传资料是否为盗版等。</li>
<li>Microsoft Word等的断字功能。</li>
</ul>
<p>动态规划小结</p>
<ul>
<li>需要再给定约束条件下优化某种指标时，动态规划很有用。</li>
<li>问题可分解为离散子问题时，可使用动态规划来解决。</li>
<li>每种动态规划解决方案都涉及网格。</li>
<li><strong>单元格中的值通常就是你要优化的值。</strong></li>
<li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</li>
<li><strong>没有放之四海皆准的计算动态规划解决方案的公式。</strong></li>
</ul>
<h1 id="k最近邻算法">10 K最近邻算法</h1>
<p>要对东西进行分类时，可首先尝试K最近邻（k-nearest neighbours, KNN，k代表多个）算法。</p>
<h2 id="创建推荐系统">创建推荐系统</h2>
<p>为用户Priyanka创建一个电影推荐系统，这本质上是分类问题，将Priyanka归类到喜好相近的人群中，然后将这群人喜好的电影推荐给他就好了。</p>
<h3 id="特征抽取">特征抽取</h3>
<p>特征抽取意味着将物品转换为一系列可比较的数字。用户注册时，要求他们指出对各种电影的喜好程度。这样，对于每位用户都将获得一组数字。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Priyanka</th>
<th>Justin</th>
<th>Morpheus</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>喜剧片</td>
<td>3</td>
<td>4</td>
<td>2</td>
</tr>
<tr class="even">
<td>动作片</td>
<td>4</td>
<td>3</td>
<td>5</td>
</tr>
<tr class="odd">
<td>生活片</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr class="even">
<td>恐怖片</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="odd">
<td>爱情片</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>毕达哥拉斯公式：<span class="math inline">\(\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+...}\)</span></p>
<p>Priyanka和Justin的距离为2，Priyanka和Morpheus的距离为<span class="math inline">\(\sqrt{24}\)</span>。所以Priyanka喜好更接近Justin，以后可以将Justin喜欢的电影推荐给Priyanka。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">10.1 归一化</span><br><span class="hljs-string">10.2 意见领袖权重大</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="回归">回归</h3>
<p>如果不仅要向Priyanka推荐电影，还要预测她将给这部电影打多少分。先看下最近邻打多少分</p>
<table>
<thead>
<tr class="header">
<th>Justin</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Jc</td>
<td>4</td>
</tr>
<tr class="even">
<td>Joet</td>
<td>4</td>
</tr>
<tr class="odd">
<td>Lance</td>
<td>5</td>
</tr>
<tr class="even">
<td>Chris</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>求平均为4.2，这就是回归（regression）。KNN的两项基本工作——分类和回归。</p>
<ul>
<li>分类就是编组。</li>
<li>回归就是预测结果（如数字）。</li>
</ul>
<p>预测应该烤多少条面包，首先需要一组特征</p>
<ul>
<li>天气指数1~5（1表示很糟，5表示很好）</li>
<li>是不是周末或节假日（是1，否0）</li>
<li>有没有活动（有1，无0）</li>
</ul>
<p>还需要一些历史数据，记录各种不同日子里售出的面包数量。</p>
<table>
<thead>
<tr class="header">
<th>第一列</th>
<th>第二列</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>A(5,1,0) = 300</strong></td>
<td><strong>B(3,1,1) = 225</strong></td>
</tr>
<tr class="even">
<td>C(1,1,0) = 75</td>
<td><strong>D(4,0,1) = 200</strong></td>
</tr>
<tr class="odd">
<td><strong>E(4,0,0) = 150</strong></td>
<td>F(2,0,0) = 50</td>
</tr>
</tbody>
</table>
<p>今天时周末，天气不错，即(4,1,0)。使用KNN算法，其中K设为4。首先，找出今天的4个最近邻。LA=1，LB=<span class="math inline">\(\sqrt{2}\)</span>，LC=3，LD=<span class="math inline">\(\sqrt{2}\)</span>，LE=1，LF=<span class="math inline">\(\sqrt{5}\)</span>。因此，4个最近邻为ABDE。求回归，即取平均为(300+225+200+150)/4=218.75条。这就是预测的今天应烤的面包数。</p>
<h4 id="余弦相似度">余弦相似度</h4>
<p>余弦相似度（cosine similarity）不计算两个矢量的距离，而是比较它们的角度。更适合处理品味类似但打分保守程度不一致的情况。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bymo/p/8489037.html">详见</a></p>
<h3 id="挑选合适的特征">挑选合适的特征</h3>
<p>在挑选合适的特征方面，没有放之四海皆准的原则，必须要考虑多种需要考虑的因素。能否挑选合适的特征事关KNN算法的成败。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 10.3 太少了。经验规则：如果有N位用户，应考虑sqrt(N)个邻居。</span><br></code></pre></td></tr></table></figure>
<h2 id="机器学习简介">机器学习简介</h2>
<p>机器学习旨在让计算机更聪明。创建推荐系统就是机器学习的一个例子。</p>
<h3 id="ocr">OCR</h3>
<p>OCR是指光学字符识别（optical character recognition）。语音识别和人脸识别也是用相同的理念。可使用KNN算法，</p>
<ul>
<li>浏览大量的数字图像，将这些数字的特征提取出来。这一步称之为训练（training）</li>
<li>遇到新图像时，提取该图像的特征，再找出它的最近邻。</li>
</ul>
<h3 id="创建垃圾邮件过滤器">创建垃圾邮件过滤器</h3>
<p>垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（Naive Bayes Classifier）。首先使用一些数据对这个分类器进行训练，即拿垃圾邮件和非垃圾邮件的主题喂食计算机。有新邮件时，分析主题中的每个单词再垃圾邮件中出现的概率。</p>
<h3 id="预测股票市场">预测股票市场</h3>
<p>不好挑选合适的特征。几乎是难以完成的任务。</p>
<h1 id="十种算法简介">11 十种算法简介</h1>
<h2 id="树">树</h2>
<p>二叉查找树（binary search tree）。对于其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。</p>
<p><img src="/ass/20220106-tree.png" srcset="/img/loading.gif" lazyload /></p>
<p>在二叉查找树查找节点时，平均运行时间为O(log n)，但在最糟糕的情况下所需时间为O(n)。而在有序数组中查找时，最糟糕情况下也只有O(log n)。但是二叉查找树的插入和删除操作的速度快得多。但二叉查找树不能随机访问元素。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>数组</th>
<th>二叉查找树</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>查找</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr class="even">
<td>插入</td>
<td>O(n)</td>
<td>O(log n)</td>
</tr>
<tr class="odd">
<td>删除</td>
<td>O(n)</td>
<td>O(log n)</td>
</tr>
</tbody>
</table>
<p>其他数据结构：B树，红黑树，堆，伸展树。</p>
<h2 id="反向索引">反向索引</h2>
<p>反向索引（inverted index）常用于创建搜索引擎。创建一个散列表，将单词（键）映射到包含他的页面（值），搜索单词即可给出包含他的页面。</p>
<h2 id="傅立叶变换">傅立叶变换</h2>
<p>信号分析领域。</p>
<h2 id="并行算法">并行算法</h2>
<p>并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。而且速度的提升并非线性的，其中的原因有两个。</p>
<ul>
<li>并行性管理开销。任务的分配与合并也是需要时间的。</li>
<li>负载均衡。分配给每个内核的任务难度可能不一样。</li>
</ul>
<p>要改善性能和可扩展性，并行算法可能是个不错的选择。</p>
<h2 id="mapreduce">MapReduce</h2>
<p>MapReduce是一种流行的分布式算法，可以通过流行的开源工具Apache Hadoop来使用它。</p>
<p>分布式算法非常适合用于在段时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（map）函数和归并（reduce）函数。</p>
<h3 id="映射函数">映射函数</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>arr2 = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span>*x, arr1) <span class="hljs-comment"># 数组元素翻倍</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(arr2)) <span class="hljs-comment"># 转换为列表打印</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = <span class="hljs-comment"># A list of URLs</span><br>arr2 = <span class="hljs-built_in">map</span>(download_page, arr1) <span class="hljs-comment"># 下载页面存储在arr2中</span><br></code></pre></td></tr></table></figure>
<h3 id="归并函数">归并函数</h3>
<p>归并是将一个数组转换为一个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>reduce(<span class="hljs-keyword">lambda</span> x,y: x+y, arr1) <span class="hljs-comment"># 将所有元素相加</span><br></code></pre></td></tr></table></figure>
<h2 id="布隆过滤器和hyperloglog">布隆过滤器和HyperLogLog</h2>
<p>布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，但很可能是正确的。为判断网页是否已搜集过，可不使用散列表（占用空间大），而使用布隆过滤器使用散列表时，答案绝对可靠，而使用布隆过滤器时，答案却是很可能是正确的。</p>
<ul>
<li>可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集。</li>
<li>不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。</li>
</ul>
<p>布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况，前面所有的示例都是这样的。对bit.ly而言，这样说完全可行：“我们认为这个网站可能是恶意的， 请倍加小心。”</p>
<h3 id="hyperloglog">HyperLogLog</h3>
<p>HyperLogLog是一种类似于布隆过滤器的算法。HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。</p>
<h2 id="sha算法">SHA算法</h2>
<h3 id="比较文件">比较文件</h3>
<p>另一种散列函数是安全散列算法（secure hash algorithm，SHA）函数。给定一个字符串， SHA返回其散列值（哈希值）。可以使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。</p>
<h3 id="检查密码">检查密码</h3>
<p>Google存储的并非密码，而是密码的SHA散列值！你输入密码时，Google计算其散列值，并将结果同其数据库中的散列值进行比较。这种 散列算法是单向的。你可根据字符串计算出散列值。但你无法根据散列值推断出原始字符串。</p>
<p>SHA实际上是一系列算法： SHA-0、 SHA-1、 SHA-2和SHA-3。本书编写期间， SHA-0和SHA-1已被发现存在一些缺陷。如果你要使用SHA算法来计算密码的散列值，请使用<strong>SHA-2</strong>或<strong>SHA-3</strong>。当前，最安全的密码散列函数是<strong>bcrypt</strong>，但没有任何东西是万无一失的。</p>
<h2 id="局部敏感的散列算法">局部敏感的散列算法</h2>
<p>SHA是局部不敏感的，即一个字符串，只改变其中一个字符，哈希值就完全不同。而Simhash是一种局部敏感的散列函数，即对字符串做细微的修改，其哈希值也只发生细微的改变。</p>
<ul>
<li>Google使用Simhash来判断网页是否已搜集。</li>
<li>老师可以使用Simhash来判断学生的论文是否是从网上抄的。</li>
<li>Scribd允许用户上传文档或图书，以便与人分享，但不希望用户上传有版权的内容！这个网站可使用Simhash来检查上传的内容是否与小说《哈利·波特》类似，如果类似，就自动拒绝。</li>
</ul>
<p>需要<strong>检查两项内容的相似程度</strong>时，Simhash很有用。</p>
<h2 id="diffie-hellman密钥交换">Diffie-Hellman密钥交换</h2>
<p>Diffie-Hellman算法解决了如下两个问题。</p>
<ul>
<li>双方无需知道加密算法。他们不必会面协商要使用的加密算法。</li>
<li>要破解加密的消息比登天还难。</li>
</ul>
<p>Diffie-Hellman使用两个密钥：公钥和私钥。有人要向你发送消息时，他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。只要只有你知道私钥，就只有你才能解密消息！</p>
<p>类似算法还要RSA。</p>
<h2 id="线性规划">线性规划</h2>
<p>线性规划用于在给定约束条件下最大限度地改善指定的指标。</p>
<p>线性规划使用Simplex算法</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/algorithm/">algorithm</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
					  <strong>本文作者: </strong><a href="/">Shixin</a><br>
					  <strong>本文链接: </strong><a href="https://physxz.github.io/posts/10016/">https://physxz.github.io/posts/10016/</a><br>
					  <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/10018/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux系统下玩转51单片机</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/10015/">
                        <span class="hidden-mobile">OpenCV项目实战</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"peSlMsKe4nkYHz6YiMvqKAO5-gzGzoHsz","appKey":"6CkCA95u7NGj6f4flvSRyd7p","path":"window.location.pathname","placeholder":"昵称处填入QQ号自动获取QQ昵称头像和邮箱，有了邮箱会收到回复提醒哟，快来试试吧\\^o^/","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div>
    <br>© 2020-2022 <a href="https://babblingme.gitee.io" target="_blank" rel="nofollow noopener">Shixin</a>. All Rights Reserved.<br/>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次 •
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人 •
    </span>
    
    
    <!-- 网站运行时间 -->
	<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("03/25/2020 00:00:00");//在此处修改你的建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = " 本站已安全运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
		setInterval("createtime()",250);
	</script>
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?2c6dc07d9ee870c7c5cde51c6acbce2d";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  



  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
